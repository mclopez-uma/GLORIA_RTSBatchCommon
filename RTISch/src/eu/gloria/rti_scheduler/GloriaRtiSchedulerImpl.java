
/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package eu.gloria.rti_scheduler;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.persistence.EntityManager;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.ws.RequestWrapper;
import javax.xml.ws.ResponseWrapper;

import org.apache.cxf.binding.corba.wsdl.Array;

import eu.gloria.rt.db.scheduler.AdvertisementState;
import eu.gloria.rt.db.scheduler.ObservingPlanManager;
import eu.gloria.rt.db.scheduler.ObservingPlanState;
import eu.gloria.rt.db.scheduler.ObservingPlanType;
import eu.gloria.rt.db.util.DBPaginationSearch;
import eu.gloria.rt.db.util.DBUtil;
import eu.gloria.rt.entity.scheduler.PlanCancelationInfo;
import eu.gloria.rt.entity.scheduler.PlanCancelationState;
import eu.gloria.rt.entity.scheduler.PlanInfo;
import eu.gloria.rt.entity.scheduler.PlanSearchFilterResult;
import eu.gloria.rt.entity.scheduler.PlanSearchPagination;
import eu.gloria.rt.entity.scheduler.PlanState;
import eu.gloria.rt.entity.scheduler.PlanStateDetail;
import eu.gloria.rt.entity.scheduler.PlanStateInfo;
import eu.gloria.rt.entity.scheduler.PlanType;
import eu.gloria.rti.sch.core.ObservingPlan;
import eu.gloria.tools.file.FileUtil;
import eu.gloria.tools.time.DateTools;


/**
 * This class was generated by Apache CXF 2.6.1
 * 2013-09-17T11:59:13.394+02:00
 * Generated source version: 2.6.1
 * 
 */

@javax.jws.WebService(
                      serviceName = "gloria_rti_scheduler",
                      portName = "gloria_rti_schedulerSOAP",
                      targetNamespace = "http://gloria.eu/rti_scheduler",
                      wsdlLocation = "http://localhost:8080/RTI_SCH/services/gloria_rti_schedulerSOAP?wsdl",
                      endpointInterface = "eu.gloria.rti_scheduler.GloriaRtiScheduler")
                      
public class GloriaRtiSchedulerImpl implements GloriaRtiScheduler {

    private static final Logger LOG = Logger.getLogger(GloriaRtiSchedulerImpl.class.getName());
    
	private String xsdFile =     "/usr/share/gloria/rts/worker/advertisement/config/gloria_rti_plan.xsd";
	private String advBasePath = "/usr/share/gloria/rts/worker/advertisement/xml/";
	
	//private String xsdFile =     "/usr/share/gloria/rts/repositories/tmp/cfg/gloria_rti_plan.xsd";
	//private String advBasePath = "/usr/share/gloria/rts/repositories/tmp/advertisement/";


    /* (non-Javadoc)
     * @see eu.gloria.rti_scheduler.GloriaRtiScheduler#planSearchByFilter(eu.gloria.rt.entity.scheduler.PlanSearchFilter  filter ,)eu.gloria.rt.entity.scheduler.PlanSearchPagination  pagination )*
     */
    public eu.gloria.rt.entity.scheduler.PlanSearchFilterResult planSearchByFilter(eu.gloria.rt.entity.scheduler.PlanSearchFilter filter,eu.gloria.rt.entity.scheduler.PlanSearchPagination pagination) throws RtiSchError    { 
    	LOG.info("Executing operation planSearchByFilter");
		System.out.println(filter);
		
		eu.gloria.rt.entity.scheduler.PlanSearchFilterResult result = new PlanSearchFilterResult();
		List<PlanInfo> items = new ArrayList<PlanInfo>();
		
		EntityManager em = DBUtil.getEntityManager();
		try{
			
			ObservingPlanManager manager = new ObservingPlanManager();
			
			DBPaginationSearch paginationSearch = new DBPaginationSearch();
			paginationSearch.setPageNumber(pagination.getPageNumber());
			paginationSearch.setPageSize(pagination.getPageSize());
			
			Date execPredictedDateIni = null;
			Date execPredictedDateEnd = null;
			Date execBeginDateIni = null;
			Date execBeginDateEnd = null;
			Date execEndDateIni = null;
			Date execEndDateEnd = null;
			Date observationSessionDate = null;
			
			String user = null;
			
			List<ObservingPlanState> planStates = new ArrayList<ObservingPlanState>();
			List<ObservingPlanType> planTypes = new ArrayList<ObservingPlanType>();
			
			if (filter != null){
				
				user = filter.getUser();
				
				if (filter.getExecPredictedDateInteval() != null && filter.getExecPredictedDateInteval().getMin() != null){
					execPredictedDateIni = DateTools.getDate(filter.getExecPredictedDateInteval().getMin());
				}
				
				if (filter.getExecPredictedDateInteval() != null && filter.getExecPredictedDateInteval().getMax() != null){
					execPredictedDateEnd = DateTools.getDate(filter.getExecPredictedDateInteval().getMax());
				}
				
				if (filter.getExecBeginDateInteval() != null && filter.getExecBeginDateInteval().getMin() != null){
					execBeginDateIni = DateTools.getDate(filter.getExecBeginDateInteval().getMin());
				}
				
				if (filter.getExecBeginDateInteval() != null && filter.getExecBeginDateInteval().getMax() != null){
					execBeginDateEnd = DateTools.getDate(filter.getExecBeginDateInteval().getMax());
				}
				
				if (filter.getExecEndDateInteval() != null && filter.getExecEndDateInteval().getMin() != null){
					execEndDateIni = DateTools.getDate(filter.getExecEndDateInteval().getMin());
				}
				
				if (filter.getExecEndDateInteval() != null && filter.getExecEndDateInteval().getMax() != null){
					execEndDateEnd = DateTools.getDate(filter.getExecEndDateInteval().getMax());
				}
				
				observationSessionDate = DateTools.getDate(filter.getObservationSession());
				
				//Resolves the plan states
				for (eu.gloria.rt.entity.scheduler.PlanState item : filter.getStates()) {
					switch (item){
					case ABORTED:
						planStates.add(ObservingPlanState.ABORTED);
						break;
					case ADVERTISE:
						planStates.add(ObservingPlanState.ADVERT_ABORTED);
						planStates.add(ObservingPlanState.ADVERT_ACCEPTED);
						planStates.add(ObservingPlanState.ADVERT_QUEUED);
						planStates.add(ObservingPlanState.ADVERT_RUNNING);
						planStates.add(ObservingPlanState.ADVERT_ERROR);
						break;
					case DONE:
						planStates.add(ObservingPlanState.DONE);
						break;
					case ERROR:
						planStates.add(ObservingPlanState.ERROR);
						break;
					case QUEUED:
						planStates.add(ObservingPlanState.QUEUED);
						planStates.add(ObservingPlanState.OFFSHORE);
						break;
					case REJECTED:
						planStates.add(ObservingPlanState.ADVERT_REJECTED);
						break;
					case RUNNING:
						planStates.add(ObservingPlanState.RUNNING);
						break;
					}
				}
				
				//Resolver the plan types
				
				
				for (eu.gloria.rt.entity.scheduler.PlanType item : filter.getTypes()) {
					switch (item){
					case BIAS:
						planTypes.add(ObservingPlanType.BIAS);
						break;
					case DARK:
						planTypes.add(ObservingPlanType.DARK);
						break;
					case FLAT:
						planTypes.add(ObservingPlanType.FLAT);
						break;
					case OBSERVATION:
						planTypes.add(ObservingPlanType.OBSERVATION);
						break;
					}
				}
				
			}
			
			//Resolves the pagination result
			long rows = manager.getCountByFilter(em, 
					paginationSearch,
					user,
					planTypes,
					planStates,
					execPredictedDateIni, 
					execPredictedDateEnd, 
					execBeginDateIni, 
					execBeginDateEnd, 
					execEndDateIni, 
					execEndDateEnd, 
					observationSessionDate);
			
			
			//LIMITATION!!!! No more than 50 items per page
			if (pagination.getPageSize() > 50){
				pagination.setPageSize(50);
			}
			
			//LIMITATION!!! current page >= 1
			if (pagination.getPageNumber() <= 0){
				pagination.setPageNumber(1);
			}
			
			eu.gloria.rt.entity.scheduler.PlanSearchPaginationInfo pagInfo = new eu.gloria.rt.entity.scheduler.PlanSearchPaginationInfo();
			int pages = 0;
			if (rows > 0){
				pages = (new Long(rows / pagination.getPageSize()).intValue());
				if ((new Long(rows % pagination.getPageSize()).intValue()) > 0) pages++;
			}
			
			pagInfo.setPageCount(pages);
			pagInfo.setPageNumber(pagination.getPageNumber());
			pagInfo.setPageSize(pagination.getPageSize());
			result.setPaginationInfo(pagInfo);
			
			//Resolves the page content
			List<eu.gloria.rt.db.scheduler.ObservingPlan> opList = manager.getByFilter(
					em, 
					paginationSearch,
					user,
					planTypes,
					planStates,
					execPredictedDateIni, 
					execPredictedDateEnd, 
					execBeginDateIni, 
					execBeginDateEnd, 
					execEndDateIni, 
					execEndDateEnd, 
					observationSessionDate);
			
			
			for (int x = 0; x < opList.size(); x++) {

				eu.gloria.rt.db.scheduler.ObservingPlan op = opList.get(x);
				
				if (op != null) {
					
					PlanInfo pi = new PlanInfo();
					pi.setUuid(op.getUuid());
					
					PlanStateInfo piInfo = new PlanStateInfo();
					pi.setStateInfo(piInfo);
					
					//User
					pi.setUser(op.getUser());
					
					//Description
					pi.setDescription(op.getDescription());
					
					//Comment
					pi.setComment(op.getComment());
					
					//Type
					switch(op.getType()){
					case BIAS:
						pi.setType(PlanType.BIAS);
						break;
					case DARK:
						pi.setType(PlanType.DARK);
						break;
					case FLAT:
						pi.setType(PlanType.FLAT);
						break;
					case OBSERVATION:
						pi.setType(PlanType.OBSERVATION);
						break;
					}
					
					//ExecDateObservationSession
					if (op.getExecDateObservationSession() != null){
						pi.setObservationSession(DateTools.getXmlGregorianCalendar(op.getExecDateObservationSession()));
					}
					
					//ExecDeadLine
					if (op.getExecDeadline() != null){
						pi.setExecDeadline(DateTools.getXmlGregorianCalendar(op.getExecDeadline()));
					}
					
					//PredAstronomical
					if (op.getPredAstr() != null){
						pi.setPredAstr(DateTools.getXmlGregorianCalendar(op.getPredAstr()));
					}
					
					//Error
					piInfo.setErrorCode(BigInteger.valueOf(0));
					if (op.getState() == ObservingPlanState.ERROR || op.getState() == ObservingPlanState.ABORTED){
						piInfo.setErrorDesc(op.getComment());
					}
					
					//State
					switch (op.getState()){
					case ADVERT_ABORTED:
					case ADVERT_ERROR:
					case ADVERT_ACCEPTED:
					case ADVERT_QUEUED:
					case ADVERT_RUNNING:
						piInfo.setState(PlanState.ADVERTISE);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					case ABORTED:
					case ABORTING:
						piInfo.setState(PlanState.ABORTED);
						piInfo.setStateDetail(PlanStateDetail.OUT_OF_TIME);
						break;
					case ADVERT_REJECTED:
						piInfo.setState(PlanState.REJECTED);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					case ERROR:
						piInfo.setState(PlanState.ERROR);
						piInfo.setStateDetail(PlanStateDetail.WRONG_BEHAVIOUR);
						break;
					case QUEUED:
						piInfo.setState(PlanState.QUEUED);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					case RUNNING:
						piInfo.setState(PlanState.RUNNING);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					case DONE:
						piInfo.setState(PlanState.DONE);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					case OFFSHORE:
						piInfo.setState(PlanState.QUEUED);
						piInfo.setStateDetail(PlanStateDetail.NONE);
						break;
					}
					
					if (op.getScheduleDateIni() != null){
						pi.setScheduleDateIni(DateTools.getXmlGregorianCalendar(op.getScheduleDateIni()));
					}
					
					if (op.getScheduleDateEnd() != null){
						pi.setScheduleDateEnd(DateTools.getXmlGregorianCalendar(op.getScheduleDateEnd()));
					}
					
					
					if (op.getState() == ObservingPlanState.DONE){
						pi.setExecDateIni(DateTools.getXmlGregorianCalendar(op.getExecDateIni()));
						pi.setExecDateEnd(DateTools.getXmlGregorianCalendar(op.getExecDateEnd()));
					}
					
					//pi.setQueuedDate(value)
					
					items.add(pi);
				}

			}
			
			result.getItems().addAll(items);
			
			
			
		}catch(Exception ex){
			ex.printStackTrace();
			throw new RtiSchError(ex.getMessage());
		}finally{
			DBUtil.close(em);
		}
		
		return result;
    }

    /* (non-Javadoc)
     * @see eu.gloria.rti_scheduler.GloriaRtiScheduler#planOffer(java.util.List<java.lang.String>  planList )*
     */
    public java.util.List<eu.gloria.rt.entity.scheduler.PlanOfferInfo> planOffer(java.util.List<java.lang.String> planList) throws RtiSchError    { 
    	LOG.info("Executing operation planOffer");
		System.out.println(planList);
		
		throw new RtiSchError("Unsupported");
    }

    /* (non-Javadoc)
     * @see eu.gloria.rti_scheduler.GloriaRtiScheduler#planSearchByUuid(java.util.List<java.lang.String>  planUuidList )*
     */
    public java.util.List<eu.gloria.rt.entity.scheduler.PlanInfo> planSearchByUuid(java.util.List<java.lang.String> planUuidList) throws RtiSchError    { 
    	LOG.info("Executing operation planSearchByUuid");
		System.out.println(planUuidList);
		
		try {
			
			List<PlanInfo> result = new ArrayList<PlanInfo>();

			if (planUuidList != null) {

				// Insert into DB.
				EntityManager em = DBUtil.getEntityManager();
				DBUtil.beginTransaction(em);

				try {
					
					ObservingPlanManager manager = new ObservingPlanManager();

					for (int x = 0; x < planUuidList.size(); x++) {

						eu.gloria.rt.db.scheduler.ObservingPlan op = manager.getByUuid(em, planUuidList.get(x));
						if (op != null) {
							PlanInfo pi = new PlanInfo();
							pi.setUuid(op.getUuid());
							
							PlanStateInfo piInfo = new PlanStateInfo();
							pi.setStateInfo(piInfo);
							
							//User
							pi.setUser(op.getUser());
							
							//Description
							pi.setDescription(op.getDescription());
							
							//Comment
							pi.setComment(op.getComment());
							
							//Type
							switch(op.getType()){
							case BIAS:
								pi.setType(PlanType.BIAS);
								break;
							case DARK:
								pi.setType(PlanType.DARK);
								break;
							case FLAT:
								pi.setType(PlanType.FLAT);
								break;
							case OBSERVATION:
								pi.setType(PlanType.OBSERVATION);
								break;
							}
							
							//ExecDateObservationSession
							if (op.getExecDateObservationSession() != null){
								pi.setObservationSession(DateTools.getXmlGregorianCalendar(op.getExecDateObservationSession()));
							}
							
							//ExecDeadLine
							if (op.getExecDeadline() != null){
								pi.setExecDeadline(DateTools.getXmlGregorianCalendar(op.getExecDeadline()));
							}
							
							//PredAstronomical
							if (op.getPredAstr() != null){
								pi.setPredAstr(DateTools.getXmlGregorianCalendar(op.getPredAstr()));
							}
							
							//Error
							piInfo.setErrorCode(BigInteger.valueOf(0));
							if (op.getState() == ObservingPlanState.ERROR || op.getState() == ObservingPlanState.ABORTED){
								piInfo.setErrorDesc(op.getComment());
							}
							
							//State
							switch (op.getState()){
							case ADVERT_ABORTED:
							case ADVERT_ERROR:
							case ADVERT_ACCEPTED:
							case ADVERT_QUEUED:
							case ADVERT_RUNNING:
								piInfo.setState(PlanState.ADVERTISE);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							case ABORTED:
							case ABORTING:
								piInfo.setState(PlanState.ABORTED);
								piInfo.setStateDetail(PlanStateDetail.OUT_OF_TIME);
								break;
							case ADVERT_REJECTED:
								piInfo.setState(PlanState.REJECTED);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							case ERROR:
								piInfo.setState(PlanState.ERROR);
								piInfo.setStateDetail(PlanStateDetail.WRONG_BEHAVIOUR);
								break;
							case QUEUED:
								piInfo.setState(PlanState.QUEUED);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							case RUNNING:
								piInfo.setState(PlanState.RUNNING);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							case DONE:
								piInfo.setState(PlanState.DONE);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							case OFFSHORE:
								piInfo.setState(PlanState.QUEUED);
								piInfo.setStateDetail(PlanStateDetail.NONE);
								break;
							}
							
							if (op.getScheduleDateIni() != null){
								pi.setScheduleDateIni(DateTools.getXmlGregorianCalendar(op.getScheduleDateIni()));
							}
							
							if (op.getScheduleDateEnd() != null){
								pi.setScheduleDateEnd(DateTools.getXmlGregorianCalendar(op.getScheduleDateEnd()));
							}
							
							if (op.getState() == ObservingPlanState.DONE){
								pi.setExecDateIni(DateTools.getXmlGregorianCalendar(op.getExecDateIni()));
								pi.setExecDateEnd(DateTools.getXmlGregorianCalendar(op.getExecDateEnd()));
							}
							
							//pi.setQueuedDate(value)
							
							result.add(pi);
						}

					}

					DBUtil.commit(em);

				} catch (Exception ex) {
					ex.printStackTrace();
					DBUtil.rollback(em);
					
					throw ex;

				} finally {
					DBUtil.close(em);
				}

			}
			
			return result;

		} catch (java.lang.Exception ex) {
			
			ex.printStackTrace();

			throw new RtiSchError(ex.getMessage());
		}
    }

    /* (non-Javadoc)
     * @see eu.gloria.rti_scheduler.GloriaRtiScheduler#planAdvertise(javax.xml.datatype.XMLGregorianCalendar  deadline ,)java.util.List<java.lang.String>  planList )*
     */
    public java.util.List<java.lang.String> planAdvertise(javax.xml.datatype.XMLGregorianCalendar deadline,java.util.List<java.lang.String> planList) throws RtiSchError    { 
    	LOG.info("Executing operation planAdvertise");

		List<ObservingPlan> ops = new ArrayList<ObservingPlan>();

		try {
			
			if (planList != null) {

				// Parser the plans....
				for (int x = 0; x < planList.size(); x++) {

					InputStream is = new ByteArrayInputStream(planList.get(x).getBytes("UTF-8"));
					try {
						
						ObservingPlan op = null;
						
						try{
							op = new ObservingPlan(is, xsdFile);
						}catch(Exception ex){
							throw new Exception("Error Parsing the Observing Plan XML");
						}
						
						if (op.getMetadata().getUser() == null || op.getMetadata().getUser().trim().length() == 0) {
							throw new Exception("Observing Plan without user metadata.");
						}
						
						if (op.getMetadata().getUuid() == null || op.getMetadata().getUuid().trim().length() == 0) {
							throw new Exception("Observing Plan without UUID metadata.");
						}
						
						ops.add(op);
					} finally {
						is.close();
					}
					
				}

				// Save the files
				for (int x = 0; x < planList.size(); x++) {
					String fullFileName = advBasePath + ops.get(x).getMetadata().getUuid() + ".xml";
					FileUtil.save(planList.get(x), new File(fullFileName), "UTF-8", true);
				}

				// Insert into DB.
				EntityManager em = DBUtil.getEntityManager();
				DBUtil.beginTransaction(em);
				
				ObservingPlanManager opManager = new ObservingPlanManager();

				try {

					for (int x = 0; x < planList.size(); x++) {
						
						//Check if the OP already exists
						if (opManager.getByUuid(em, ops.get(x).getMetadata().getUuid()) != null){
							throw new Exception("The Observing Plan already has been managed by this RTS. UUID=" + ops.get(x).getMetadata().getUuid());
						}


						eu.gloria.rt.db.scheduler.ObservingPlan op = new eu.gloria.rt.db.scheduler.ObservingPlan();
						op.setAdvertDeadline(DateTools.getDate(deadline));
						op.setFile(ops.get(x).getMetadata().getUuid() + ".xml");
						op.setPriority(0);
						op.setDescription(ops.get(x).getMetadata().getDescription());
						op.setReceivedDate(new Date());
						op.setState(ObservingPlanState.ADVERT_QUEUED);
						op.setUser(ops.get(x).getMetadata().getUser());
						op.setUuid(ops.get(x).getMetadata().getUuid());
						op.setType(ObservingPlanType.OBSERVATION);

						em.persist(op);

					}

					DBUtil.commit(em);

				} catch (Exception ex) {
					ex.printStackTrace();
					DBUtil.rollback(em);
					
					throw ex;

				} finally {
					DBUtil.close(em);
				}

			}

			// Returns empty list
			return new ArrayList<String>();

		} catch (java.lang.Exception ex) {
			
			ex.printStackTrace();

			// Deletes files
			if (planList != null && planList.size() == ops.size()){
				for (int x = 0; x < planList.size(); x++) {
					String fullFileName = advBasePath + ops.get(x).getMetadata().getUuid() + ".xml";
					File file = new File(fullFileName);
					if (file.exists()) {
						try {
							file.delete();
						} catch (Exception ex1) {
							ex1.printStackTrace();
						}
					}
				}
			}

			throw new RtiSchError(ex.getMessage());
		}
    }

    /* (non-Javadoc)
     * @see eu.gloria.rti_scheduler.GloriaRtiScheduler#planCancel(java.util.List<java.lang.String>  planUuidList )*
     */
    public java.util.List<eu.gloria.rt.entity.scheduler.PlanCancelationInfo> planCancel(java.util.List<java.lang.String> planUuidList) throws RtiSchError    { 
    	LOG.info("Executing operation planSearchByUuid");
		System.out.println(planUuidList);
		
		try {
			
			Date now = new Date();
			
			List<PlanCancelationInfo> result = new ArrayList<PlanCancelationInfo>();

			if (planUuidList != null) {
				
				for (int x = 0; x < planUuidList.size(); x++) {

					EntityManager em = DBUtil.getEntityManager();
					DBUtil.beginTransaction(em);

					try {
					
						ObservingPlanManager manager = new ObservingPlanManager();

						eu.gloria.rt.db.scheduler.ObservingPlan op = manager.getByUuid(em, planUuidList.get(x));
						
						PlanCancelationInfo info = new PlanCancelationInfo();
						info.setUuid(planUuidList.get(x));
						
						if (op != null) {
							
							Date limit = DateTools.increment(op.getScheduleDateIni(), Calendar.HOUR, -5);
							
							if (now.compareTo(limit) >= 0){ //now > limit
								info.setState(PlanCancelationState.TOO_LATE);
							}else{
								
								if (op.getState() == ObservingPlanState.OFFSHORE){
									op.setState(ObservingPlanState.ABORTING);
								} else{
									op.setState(ObservingPlanState.ABORTED);
								}
								
								info.setState(PlanCancelationState.OK);
							}
							
						}else{
							info.setState(PlanCancelationState.INVALID_UUID);
						}
						
						result.add(info);

						DBUtil.commit(em);

					} catch (Exception ex) {
						ex.printStackTrace();
						DBUtil.rollback(em);
					
						throw ex;

					} finally {
						DBUtil.close(em);
					}
				
				}

			}
			
			return result;

		} catch (java.lang.Exception ex) {
			
			ex.printStackTrace();

			throw new RtiSchError(ex.getMessage());
		}
    }

}
