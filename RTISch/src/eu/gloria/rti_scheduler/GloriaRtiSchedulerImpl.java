/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package eu.gloria.rti_scheduler;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import javax.persistence.EntityManager;

import eu.gloria.rt.db.scheduler.Advertisement;
import eu.gloria.rt.db.scheduler.AdvertisementManager;
import eu.gloria.rt.db.scheduler.AdvertisementState;
import eu.gloria.rt.db.scheduler.ObservingPlanManager;
import eu.gloria.rt.db.scheduler.ObservingPlanState;
import eu.gloria.rt.db.util.DBUtil;
import eu.gloria.rt.entity.scheduler.PlanInfo;
import eu.gloria.rt.entity.scheduler.PlanState;
import eu.gloria.rt.entity.scheduler.PlanStateDetail;
import eu.gloria.rt.entity.scheduler.PlanStateInfo;
import eu.gloria.rti.sch.core.ObservingPlan;
import eu.gloria.tools.file.FileUtil;
import eu.gloria.tools.time.DateTools;

/**
 * This class was generated by Apache CXF 2.6.1 2013-03-14T08:46:17.728+01:00
 * Generated source version: 2.6.1
 * 
 */

@javax.jws.WebService(serviceName = "gloria_rti_scheduler", portName = "gloria_rti_schedulerSOAP", targetNamespace = "http://gloria.eu/rti_scheduler", wsdlLocation = "http://localhost:8080/RTI_SCH/services/gloria_rti_schedulerSOAP?wsdl", endpointInterface = "eu.gloria.rti_scheduler.GloriaRtiScheduler")
public class GloriaRtiSchedulerImpl implements GloriaRtiScheduler {

	private static final Logger LOG = Logger.getLogger(GloriaRtiSchedulerImpl.class.getName());

	private String xsdFile = "/usr/share/gloria/rts/repositories/tmp/cfg/gloria_rti_plan.xsd";
	private String advBasePath = "/usr/share/gloria/rts/repositories/tmp/advertisement/";

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * eu.gloria.rti_scheduler.GloriaRtiScheduler#planSearchByFilter(eu.gloria
	 * .rt.entity.scheduler.PlanSearchFilter filter )*
	 */
	public java.util.List<eu.gloria.rt.entity.scheduler.PlanInfo> planSearchByFilter(
			eu.gloria.rt.entity.scheduler.PlanSearchFilter filter)
			throws RtiSchError {
		
		LOG.info("Executing operation planSearchByFilter");
		System.out.println(filter);
		
		List<PlanInfo> result = new ArrayList<PlanInfo>();
		
		EntityManager em = DBUtil.getEntityManager();
		try{
			
			ObservingPlanManager manager = new ObservingPlanManager();
			
			List<eu.gloria.rt.db.scheduler.ObservingPlan> opList = manager.getAll(em);

			for (int x = 0; x < opList.size(); x++) {

				eu.gloria.rt.db.scheduler.ObservingPlan op = opList.get(x);
				
				if (op != null) {
					
					PlanInfo pi = new PlanInfo();
					pi.setUuid(op.getUuid());
					
					PlanStateInfo piInfo = new PlanStateInfo();
					pi.setStateInfo(piInfo);
					
					//Error
					piInfo.setErrorCode(BigInteger.valueOf(0));
					if (op.getState() == ObservingPlanState.ERROR || op.getState() == ObservingPlanState.ABORTED){
						piInfo.setErrorDesc(op.getComment());
					}
					
					//State
					switch (op.getState()){
						case ABORTED:
							piInfo.setState(PlanState.CANCEL);
							piInfo.setStateDetail(PlanStateDetail.OUT_OF_TIME);
							break;
						case ERROR:
							piInfo.setState(PlanState.ERROR);
							piInfo.setStateDetail(PlanStateDetail.WRONG_BEHAVIOUR);
							break;
						case QUEUED:
							piInfo.setState(PlanState.QUEUED);
							piInfo.setStateDetail(PlanStateDetail.NONE);
							break;
						case RUNNING:
							piInfo.setState(PlanState.RUNNING);
							piInfo.setStateDetail(PlanStateDetail.NONE);
							break;
						case DONE:
							piInfo.setState(PlanState.DONE);
							piInfo.setStateDetail(PlanStateDetail.NONE);
							break;
						case OFFSHORE:
							piInfo.setState(PlanState.QUEUED);
							piInfo.setStateDetail(PlanStateDetail.NONE);
							break;
					}
					
					
					
					if (op.getState() == ObservingPlanState.DONE){
						pi.setExecbeginDate(DateTools.getXmlGregorianCalendar(op.getExecDateIni()));
						pi.setExecEndDate(DateTools.getXmlGregorianCalendar(op.getExecDateEnd()));
					}
					
					//pi.setQueuedDate(value)
					
					result.add(pi);
				}

			}
			
		}catch(Exception ex){
			ex.printStackTrace();
			throw new RtiSchError(ex.getMessage());
		}finally{
			DBUtil.close(em);
		}
		
		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * eu.gloria.rti_scheduler.GloriaRtiScheduler#planOffer(java.util.List<java
	 * .lang.String> planList )*
	 */
	public java.util.List<eu.gloria.rt.entity.scheduler.PlanOfferInfo> planOffer(
			java.util.List<java.lang.String> planList) throws RtiSchError {
		LOG.info("Executing operation planOffer");
		System.out.println(planList);
		
		throw new RtiSchError("Unsupported");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * eu.gloria.rti_scheduler.GloriaRtiScheduler#planSearchByUuid(java.util
	 * .List<java.lang.String> planUuidList )*
	 */
	public java.util.List<eu.gloria.rt.entity.scheduler.PlanInfo> planSearchByUuid(
			java.util.List<java.lang.String> planUuidList) throws RtiSchError {
		LOG.info("Executing operation planSearchByUuid");
		System.out.println(planUuidList);
		
		try {
			
			List<PlanInfo> result = new ArrayList<PlanInfo>();

			if (planUuidList != null) {

				// Insert into DB.
				EntityManager em = DBUtil.getEntityManager();
				DBUtil.beginTransaction(em);

				try {
					
					ObservingPlanManager manager = new ObservingPlanManager();

					for (int x = 0; x < planUuidList.size(); x++) {

						eu.gloria.rt.db.scheduler.ObservingPlan op = manager.getByUuid(em, planUuidList.get(x));
						if (op != null) {
							PlanInfo pi = new PlanInfo();
							pi.setUuid(op.getUuid());
							
							PlanStateInfo piInfo = new PlanStateInfo();
							pi.setStateInfo(piInfo);
							
							//Error
							piInfo.setErrorCode(BigInteger.valueOf(0));
							if (op.getState() == ObservingPlanState.ERROR || op.getState() == ObservingPlanState.ABORTED){
								piInfo.setErrorDesc(op.getComment());
							}
							
							//State
							switch (op.getState()){
								case ABORTED:
									piInfo.setState(PlanState.CANCEL);
									piInfo.setStateDetail(PlanStateDetail.OUT_OF_TIME);
									break;
								case ERROR:
									piInfo.setState(PlanState.ERROR);
									piInfo.setStateDetail(PlanStateDetail.WRONG_BEHAVIOUR);
									break;
								case QUEUED:
									piInfo.setState(PlanState.QUEUED);
									piInfo.setStateDetail(PlanStateDetail.NONE);
									break;
								case RUNNING:
									piInfo.setState(PlanState.RUNNING);
									piInfo.setStateDetail(PlanStateDetail.NONE);
									break;
								case DONE:
									piInfo.setState(PlanState.DONE);
									piInfo.setStateDetail(PlanStateDetail.NONE);
									break;
								case OFFSHORE:
									piInfo.setState(PlanState.QUEUED);
									piInfo.setStateDetail(PlanStateDetail.NONE);
									break;
							}
							
							
							
							if (op.getState() == ObservingPlanState.DONE){
								pi.setExecbeginDate(DateTools.getXmlGregorianCalendar(op.getExecDateIni()));
								pi.setExecEndDate(DateTools.getXmlGregorianCalendar(op.getExecDateEnd()));
							}
							
							//pi.setQueuedDate(value)
							
							result.add(pi);
						}

					}

					DBUtil.commit(em);

				} catch (Exception ex) {
					ex.printStackTrace();
					DBUtil.rollback(em);
					
					throw ex;

				} finally {
					DBUtil.close(em);
				}

			}
			
			return result;

		} catch (java.lang.Exception ex) {
			
			ex.printStackTrace();

			throw new RtiSchError(ex.getMessage());
		}
	}

	public java.util.List<java.lang.String> planAdvertise(
			javax.xml.datatype.XMLGregorianCalendar deadline,
			java.util.List<java.lang.String> planList) throws RtiSchError {
		LOG.info("Executing operation planAdvertise");

		List<ObservingPlan> ops = new ArrayList<ObservingPlan>();

		try {

			if (planList != null) {

				// Parser the plans....
				for (int x = 0; x < planList.size(); x++) {

					InputStream is = new ByteArrayInputStream(planList.get(x).getBytes("UTF-8"));
					try {
						
						ObservingPlan op = null;
						
						try{
							op = new ObservingPlan(is, xsdFile);
						}catch(Exception ex){
							throw new Exception("Error Parsing the Observing Plan XML");
						}
						
						if (op.getMetadata().getUser() == null || op.getMetadata().getUser().trim().length() == 0) {
							throw new Exception("Observing Plan without user metadata.");
						}
						
						if (op.getMetadata().getUuid() == null || op.getMetadata().getUuid().trim().length() == 0) {
							throw new Exception("Observing Plan without UUID metadata.");
						}
						
						ops.add(op);
					} finally {
						is.close();
					}
					
				}

				// Save the files
				for (int x = 0; x < planList.size(); x++) {
					String fullFileName = advBasePath + ops.get(x).getMetadata().getUuid() + ".xml";
					FileUtil.save(planList.get(x), new File(fullFileName), "UTF-8", true);
				}

				// Insert into DB.
				EntityManager em = DBUtil.getEntityManager();
				DBUtil.beginTransaction(em);
				
				AdvertisementManager advManager = new AdvertisementManager();

				try {

					for (int x = 0; x < planList.size(); x++) {
						
						//Check if the OP already exists
						if (advManager.getByUuid(em, ops.get(x).getMetadata().getUuid()) != null){
							throw new Exception("The Observing Plan already has been managed by this RTS. UUID=" + ops.get(x).getMetadata().getUuid());
						}


						Advertisement adv = new Advertisement();
						adv.setDeadline(DateTools.getDate(deadline));
						adv.setFile(ops.get(x).getMetadata().getUuid() + ".xml");
						adv.setPriority("0");
						adv.setReceived(new Date());
						adv.setState(AdvertisementState.PENDING);
						adv.setUser(ops.get(x).getMetadata().getUser());
						adv.setUuid(ops.get(x).getMetadata().getUuid());

						em.persist(adv);

					}

					DBUtil.commit(em);

				} catch (Exception ex) {
					ex.printStackTrace();
					DBUtil.rollback(em);
					
					throw ex;

				} finally {
					DBUtil.close(em);
				}

			}

			// Returns empty list
			return new ArrayList<String>();

		} catch (java.lang.Exception ex) {
			
			ex.printStackTrace();

			// Deletes files
			if (planList != null && planList.size() == ops.size()){
				for (int x = 0; x < planList.size(); x++) {
					String fullFileName = advBasePath + ops.get(x).getMetadata().getUuid() + ".xml";
					File file = new File(fullFileName);
					if (file.exists()) {
						try {
							file.delete();
						} catch (Exception ex1) {
							ex1.printStackTrace();
						}
					}
				}
			}

			throw new RtiSchError(ex.getMessage());
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * eu.gloria.rti_scheduler.GloriaRtiScheduler#planCancel(java.util.List<
	 * java.lang.String> planUuidList )*
	 */
	public java.util.List<eu.gloria.rt.entity.scheduler.PlanCancelationInfo> planCancel(
			java.util.List<java.lang.String> planUuidList) throws RtiSchError {
		LOG.info("Executing operation planCancel");
		System.out.println(planUuidList);
		
		throw new RtiSchError("Unsupported");
	}

}
